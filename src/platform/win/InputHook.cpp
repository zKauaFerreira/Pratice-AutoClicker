#include "platform/win/InputHook.h"
#include "core/AutoClicker.h"

// Initialize static members
AutoClicker* InputHook::s_app = nullptr;

InputHook::InputHook() : m_keyboardHook(NULL), m_mouseHook(NULL) {}

void InputHook::Install(AutoClicker* app) {
    s_app = app;
    m_keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, GetModuleHandle(NULL), 0);
    m_mouseHook = SetWindowsHookEx(WH_MOUSE_LL, LowLevelMouseProc, GetModuleHandle(NULL), 0);
}

void InputHook::Uninstall() {
    if (m_keyboardHook) {
        UnhookWindowsHookEx(m_keyboardHook);
        m_keyboardHook = NULL;
    }
    if (m_mouseHook) {
        UnhookWindowsHookEx(m_mouseHook);
        m_mouseHook = NULL;
    }
}

// Define a magic value to distinguish synthetic input
#define APP_EXTRA_INFO 0xABCDE

LRESULT CALLBACK InputHook::LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && s_app) {
        KBDLLHOOKSTRUCT* pkbhs = (KBDLLHOOKSTRUCT*)lParam;

        if (pkbhs->dwExtraInfo == APP_EXTRA_INFO) {
            return CallNextHookEx(NULL, nCode, wParam, lParam);
        }

        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            int toggleKey = s_app->GetConfigManager()->Get<int>("toggleKey", VK_END);
            if (pkbhs->vkCode == static_cast<DWORD>(toggleKey)) {
                s_app->ToggleEnabled();
                return 1; 
            }

            // Check for the kill switch (Ctrl + Shift + End)
            int killKey = s_app->GetConfigManager()->GetKey("Others").value("killSwitchKey", VK_END);
            if ((GetAsyncKeyState(VK_CONTROL) & 0x8000) && (GetAsyncKeyState(VK_SHIFT) & 0x8000) && pkbhs->vkCode == static_cast<DWORD>(killKey)) {
                PostMessage(s_app->GetWindowHandle(), WM_DESTROY, 0, 0);
                return 1;
            }
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

LRESULT CALLBACK InputHook::LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && s_app) {
        if (s_app->IsMenuOpen()) {
            return CallNextHookEx(NULL, nCode, wParam, lParam);
        }

        MSLLHOOKSTRUCT* pmslhs = (MSLLHOOKSTRUCT*)lParam;

        // Check if the event was generated by our app and ignore it
        if (pmslhs->dwExtraInfo == APP_EXTRA_INFO) {
            return CallNextHookEx(NULL, nCode, wParam, lParam);
        }

        // Handle toggle keys that are mouse buttons
        if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN || wParam == WM_XBUTTONDOWN) {
            int toggleKey = s_app->GetConfigManager()->Get<int>("toggleKey", VK_NUMPAD1);
            DWORD vkCode = 0;

            if (wParam == WM_LBUTTONDOWN) vkCode = VK_LBUTTON;
            else if (wParam == WM_RBUTTONDOWN) vkCode = VK_RBUTTON;
            else if (wParam == WM_MBUTTONDOWN) vkCode = VK_MBUTTON;
            else if (wParam == WM_XBUTTONDOWN) {
                if (HIWORD(pmslhs->mouseData) == XBUTTON1) vkCode = VK_XBUTTON1;
                else if (HIWORD(pmslhs->mouseData) == XBUTTON2) vkCode = VK_XBUTTON2;
            }

            if (vkCode != 0 && vkCode == static_cast<DWORD>(toggleKey)) {
                s_app->ToggleEnabled();
                // We should not pass the toggle key press to the system
                return 1;
            }
        }
        
        if (s_app->IsEnabled()) {
            ClickHandler* clicker = s_app->GetClickHandler();
            ConfigManager* cfg = s_app->GetConfigManager();
            json clickerOptions = cfg->GetKey("ClickerOptions");

            switch (wParam) {
                case WM_LBUTTONDOWN:
                    if (clickerOptions.value("mouse1Enabled", true)) {
                        clicker->SetButtonState(MouseButton::M1, true);
                    }
                    return CallNextHookEx(NULL, nCode, wParam, lParam);
                case WM_LBUTTONUP:
                    if (clickerOptions.value("mouse1Enabled", true)) {
                        clicker->SetButtonState(MouseButton::M1, false);
                    }
                    return CallNextHookEx(NULL, nCode, wParam, lParam);
                case WM_RBUTTONDOWN:
                    if (clickerOptions.value("mouse2Enabled", true)) {
                        clicker->SetButtonState(MouseButton::M2, true);
                    }
                    return CallNextHookEx(NULL, nCode, wParam, lParam);
                case WM_RBUTTONUP:
                    if (clickerOptions.value("mouse2Enabled", true)) {
                        clicker->SetButtonState(MouseButton::M2, false);
                    }
                    return CallNextHookEx(NULL, nCode, wParam, lParam);
                case WM_XBUTTONDOWN: {
                    if (HIWORD(pmslhs->mouseData) == XBUTTON1) {
                        if (clickerOptions.value("mouse4Enabled", true)) {
                            clicker->ToggleSpamMode(MouseButton::M4);
                        }
                        return CallNextHookEx(NULL, nCode, wParam, lParam);
                    } else if (HIWORD(pmslhs->mouseData) == XBUTTON2) {
                        if (clickerOptions.value("mouse5Enabled", true)) {
                            clicker->ToggleSpamMode(MouseButton::M5);
                        }
                        return CallNextHookEx(NULL, nCode, wParam, lParam);
                    }
                    break;
                }
            }
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}
